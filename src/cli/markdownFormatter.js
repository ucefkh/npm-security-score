/**
 * Markdown report formatter
 * Generates markdown-formatted security reports
 */

class MarkdownFormatter {
  constructor() {
    this.timestamp = new Date().toISOString();
  }

  /**
   * Format result as Markdown
   * @param {Object} result - Scoring result
   * @returns {string} Markdown formatted report
   */
  format(result) {
    const lines = [];

    // Header
    lines.push('# Security Score Report');
    lines.push('');
    lines.push(`**Package:** \`${result.packageName}@${result.packageVersion}\``);
    lines.push(`**Generated:** ${new Date(result.timestamp).toLocaleString()}`);
    lines.push('');

    // Executive Summary
    lines.push('## Executive Summary');
    lines.push('');
    lines.push(this._formatSummary(result));
    lines.push('');

    // Score
    lines.push('## Security Score');
    lines.push('');
    lines.push(this._formatScore(result));
    lines.push('');

    // Rule Results
    if (result.ruleResults && result.ruleResults.length > 0) {
      lines.push('## Security Analysis');
      lines.push('');
      lines.push(this._formatRuleResults(result.ruleResults));
      lines.push('');
    }

    // Recommendations
    lines.push('## Recommendations');
    lines.push('');
    lines.push(this._formatRecommendations(result));
    lines.push('');

    // Remediation Steps
    const remediation = this._getRemediationSteps(result);
    if (remediation.length > 0) {
      lines.push('## Remediation Steps');
      lines.push('');
      lines.push(remediation);
      lines.push('');
    }

    // Footer
    lines.push('---');
    lines.push('');
    lines.push(`*Report generated by npm-security-score v${require('../../package.json').version}*`);
    lines.push('');

    return lines.join('\n');
  }

  /**
   * Format executive summary
   * @private
   */
  _formatSummary(result) {
    const totalIssues = (result.ruleResults || []).filter(
      (r) => r.deduction > 0
    ).length;
    const emoji = result.band.emoji;
    const status = result.score >= 90 ? 'âœ… Safe' : result.score >= 70 ? 'âš ï¸ Review Recommended' : result.score >= 50 ? 'âŒ High Risk' : 'ðŸš¨ Block';

    return `| Metric | Value |
|--------|-------|
| **Security Score** | ${result.score}/100 ${emoji} |
| **Status** | ${status} |
| **Risk Level** | ${result.band.label} |
| **Issues Found** | ${totalIssues} |
| **Rules Evaluated** | ${result.ruleResults?.length || 0} |`;
  }

  /**
   * Format score section
   * @private
   */
  _formatScore(result) {
    const lines = [];
    const scoreBar = this._generateScoreBar(result.score);

    lines.push(`### ${result.score}/100 ${result.band.emoji} ${result.band.label}`);
    lines.push('');
    lines.push(scoreBar);
    lines.push('');
    lines.push(`*${result.band.description}*`);
    lines.push('');

    return lines.join('\n');
  }

  /**
   * Generate visual score bar
   * @private
   */
  _generateScoreBar(score) {
    const barLength = 50;
    const filled = Math.round((score / 100) * barLength);
    const empty = barLength - filled;
    const bar = 'â–ˆ'.repeat(filled) + 'â–‘'.repeat(empty);
    return `\`${bar}\` ${score}%`;
  }

  /**
   * Format rule results
   * @private
   */
  _formatRuleResults(ruleResults) {
    const lines = [];

    ruleResults.forEach((rule, index) => {
      lines.push(`### ${index + 1}. ${this._formatRuleName(rule.ruleName)}`);
      lines.push('');

      if (rule.deduction > 0) {
        lines.push(`- **Deduction:** -${rule.deduction} points`);
        lines.push(`- **Risk Level:** ${this._formatRiskLevel(rule.riskLevel)}`);
      } else {
        lines.push(`- **Status:** âœ… No issues detected`);
      }

      if (rule.details && rule.details.findings) {
        lines.push('');
        lines.push('#### Findings:');
        lines.push('');
        rule.details.findings.forEach((finding) => {
          lines.push(`- **${finding.hook || 'Issue'}:** ${finding.description || 'Security concern detected'}`);
          if (finding.issues && Array.isArray(finding.issues)) {
            finding.issues.forEach((issue) => {
              lines.push(`  - ${issue.type}: ${issue.description}`);
            });
          }
        });
      }

      lines.push('');
    });

    return lines.join('\n');
  }

  /**
   * Format rule name for display
   * @private
   */
  _formatRuleName(ruleName) {
    return ruleName
      .split('-')
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }

  /**
   * Format risk level
   * @private
   */
  _formatRiskLevel(riskLevel) {
    const emojis = {
      none: 'âœ…',
      low: 'ðŸŸ¡',
      medium: 'ðŸŸ ',
      high: 'ðŸ”´',
      critical: 'ðŸš¨',
    };
    return `${emojis[riskLevel] || ''} ${riskLevel.charAt(0).toUpperCase() + riskLevel.slice(1)}`;
  }

  /**
   * Format recommendations
   * @private
   */
  _formatRecommendations(result) {
    const lines = [];
    const recommendations = this._getRecommendations(result);

    if (recommendations.length === 0) {
      lines.push('âœ… No specific recommendations. Package appears secure.');
      return lines.join('\n');
    }

    recommendations.forEach((rec, index) => {
      lines.push(`### ${index + 1}. ${rec.message}`);
      lines.push('');
      lines.push(`**Priority:** ${rec.priority}`);
      lines.push(`**Action:** ${rec.action}`);
      if (rec.remediation && Array.isArray(rec.remediation)) {
        lines.push('');
        lines.push('**Remediation Steps:**');
        lines.push('');
        rec.remediation.forEach((step) => {
          lines.push(`- ${step}`);
        });
      }
      lines.push('');
    });

    return lines.join('\n');
  }

  /**
   * Get recommendations for result
   * @private
   */
  _getRecommendations(result) {
    const recommendations = [];

    // General recommendations based on score
    if (result.score < 50) {
      recommendations.push({
        priority: 'Critical',
        action: 'Block',
        message: 'Package should be blocked in CI/CD due to significant security concerns.',
      });
    } else if (result.score < 70) {
      recommendations.push({
        priority: 'High',
        action: 'Review',
        message: 'Thorough security review recommended before use in production.',
      });
    }

    // Rule-specific recommendations
    (result.ruleResults || []).forEach((rule) => {
      if (rule.deduction > 0) {
        const rec = this._getRuleRecommendation(rule);
        if (rec) {
          recommendations.push(rec);
        }
      }
    });

    return recommendations;
  }

  /**
   * Get rule-specific recommendation
   * @private
   */
  _getRuleRecommendation(rule) {
    const recommendations = {
      'lifecycle-script-risk': {
        priority: 'High',
        action: 'Review Scripts',
        message: 'Review and remove suspicious lifecycle scripts.',
        remediation: [
          'Examine all preinstall/postinstall scripts',
          'Remove scripts that download or execute remote code',
          'Verify script contents are legitimate',
        ],
      },
      'external-network-call': {
        priority: 'High',
        action: 'Review Network Calls',
        message: 'Verify external network calls are secure and necessary.',
        remediation: [
          'Review network call destinations',
          'Ensure all connections use HTTPS',
          'Verify network calls are legitimate',
        ],
      },
      'maintainer-security': {
        priority: 'Medium',
        action: 'Contact Maintainers',
        message: 'Consider contacting maintainers about security improvements.',
        remediation: [
          'Check repository for security policy',
          'Verify maintainer account security',
          'Consider contributing security improvements',
        ],
      },
      'code-obfuscation': {
        priority: 'Medium',
        action: 'Review Source',
        message: 'Request source code access if package is obfuscated.',
        remediation: [
          'Request source code from maintainers',
          'Review minified code for suspicious patterns',
          'Consider alternatives if source unavailable',
        ],
      },
      'advisory-history': {
        priority: 'High',
        action: 'Update Package',
        message: 'Update to patched version if available.',
        remediation: [
          'Check for updated versions with security patches',
          'Review advisory details and CVEs',
          'Apply security updates promptly',
        ],
      },
      'update-behavior': {
        priority: 'Medium',
        action: 'Review Updates',
        message: 'Review recent version changes for suspicious patterns.',
        remediation: [
          'Review changelog for recent updates',
          'Verify update authenticity',
          'Check for unexpected changes',
        ],
      },
      'community-signals': {
        priority: 'Low',
        action: 'Monitor',
        message: 'Monitor repository for activity and security improvements.',
        remediation: [
          'Monitor repository activity',
          'Check for security policy updates',
          'Consider contributing improvements',
        ],
      },
    };

    return recommendations[rule.ruleName] || null;
  }

  /**
   * Get remediation steps
   * @private
   */
  _getRemediationSteps(result) {
    const steps = [];
    const recommendations = this._getRecommendations(result);

    recommendations.forEach((rec) => {
      if (rec.remediation && Array.isArray(rec.remediation)) {
        rec.remediation.forEach((step) => {
          if (!steps.includes(step)) {
            steps.push(step);
          }
        });
      }
    });

    if (steps.length === 0) {
      return 'No specific remediation steps required.';
    }

    return steps.map((step, index) => `${index + 1}. ${step}`).join('\n');
  }
}

module.exports = MarkdownFormatter;

